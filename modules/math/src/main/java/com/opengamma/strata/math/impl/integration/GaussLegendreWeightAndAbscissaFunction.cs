using System;

/*
 * Copyright (C) 2009 - present by OpenGamma Inc. and the OpenGamma group of companies
 *
 * Please see distribution for license.
 */
namespace com.opengamma.strata.math.impl.integration
{
	using ArgChecker = com.opengamma.strata.collect.ArgChecker;
	using Pair = com.opengamma.strata.collect.tuple.Pair;
	using DoubleFunction1D = com.opengamma.strata.math.impl.function.DoubleFunction1D;
	using LegendrePolynomialFunction = com.opengamma.strata.math.impl.function.special.LegendrePolynomialFunction;
	using NewtonRaphsonSingleRootFinder = com.opengamma.strata.math.impl.rootfinding.NewtonRaphsonSingleRootFinder;

	/// <summary>
	/// Class that generates weights and abscissas for Gauss-Legendre quadrature.
	/// The weights $w_i$ are given by:
	/// $$
	/// \begin{align*}
	/// w_i = \frac{2}{(1 - x_i^2) L_i'(x_i)^2}
	/// \end{align*}
	/// $$
	/// where $x_i$ is the $i^{th}$ root of the orthogonal polynomial and $L_i'$ is
	/// the first derivative of the $i^{th}$ polynomial. The orthogonal polynomial
	/// is generated by
	/// <seealso cref="LegendrePolynomialFunction"/>.
	/// </summary>
	public class GaussLegendreWeightAndAbscissaFunction : QuadratureWeightAndAbscissaFunction
	{

	  private static readonly LegendrePolynomialFunction LEGENDRE = new LegendrePolynomialFunction();
	  private static readonly NewtonRaphsonSingleRootFinder ROOT_FINDER = new NewtonRaphsonSingleRootFinder(1e-15);

	  /// <summary>
	  /// {@inheritDoc}
	  /// </summary>
	  public virtual GaussianQuadratureData generate(int n)
	  {
		ArgChecker.isTrue(n > 0);
		int mid = (n + 1) / 2;
		double[] x = new double[n];
		double[] w = new double[n];
		Pair<DoubleFunction1D, DoubleFunction1D>[] polynomials = LEGENDRE.getPolynomialsAndFirstDerivative(n);
		Pair<DoubleFunction1D, DoubleFunction1D> pair = polynomials[n];
		DoubleFunction1D function = pair.First;
		DoubleFunction1D derivative = pair.Second;
		for (int i = 0; i < mid; i++)
		{
		  double root = ROOT_FINDER.getRoot(function, derivative, getInitialRootGuess(i, n)).Value;
		  x[i] = -root;
		  x[n - i - 1] = root;
		  double dp = derivative.applyAsDouble(root);
		  w[i] = 2 / ((1 - root * root) * dp * dp);
		  w[n - i - 1] = w[i];
		}
		return new GaussianQuadratureData(x, w);
	  }

	  private double getInitialRootGuess(int i, int n)
	  {
		return Math.Cos(Math.PI * (i + 0.75) / (n + 0.5));
	  }

	}

}